//
// Generated by Bluespec Compiler, version 2023.01-6-g034050db (build 034050db)
//
// On Tue May  9 17:54:29 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_put                        O     1 reg
// RDY_configure                  O     1 const
// get                            O   256 reg
// RDY_get                        O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_datas                      I   256 reg
// configure_shift                I    10 reg
// configure_ker                  I     4 reg
// EN_put                         I     1
// EN_configure                   I     1
// EN_get                         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCoalesce2(CLK,
		   RST_N,

		   put_datas,
		   EN_put,
		   RDY_put,

		   configure_shift,
		   configure_ker,
		   EN_configure,
		   RDY_configure,

		   EN_get,
		   get,
		   RDY_get);
  input  CLK;
  input  RST_N;

  // action method put
  input  [255 : 0] put_datas;
  input  EN_put;
  output RDY_put;

  // action method configure
  input  [9 : 0] configure_shift;
  input  [3 : 0] configure_ker;
  input  EN_configure;
  output RDY_configure;

  // actionvalue method get
  input  EN_get;
  output [255 : 0] get;
  output RDY_get;

  // signals for module outputs
  wire [255 : 0] get;
  wire RDY_configure, RDY_get, RDY_put;

  // inlined wires
  wire [1 : 0] p0_rv$port1__read,
	       p0_rv$port2__read,
	       p1_rv$port1__read,
	       p1_rv$port2__read,
	       p2_rv$port1__read,
	       p2_rv$port2__read;
  wire p0_rv$EN_port1__write, p1_rv$EN_port1__write;

  // register _unnamed_
  reg [255 : 0] _unnamed_;
  wire [255 : 0] _unnamed_$D_IN;
  wire _unnamed_$EN;

  // register _unnamed__1
  reg [255 : 0] _unnamed__1;
  wire [255 : 0] _unnamed__1$D_IN;
  wire _unnamed__1$EN;

  // register _unnamed__2
  reg [255 : 0] _unnamed__2;
  wire [255 : 0] _unnamed__2$D_IN;
  wire _unnamed__2$EN;

  // register _unnamed__3
  reg [255 : 0] _unnamed__3;
  wire [255 : 0] _unnamed__3$D_IN;
  wire _unnamed__3$EN;

  // register count
  reg [3 : 0] count;
  wire [3 : 0] count$D_IN;
  wire count$EN;

  // register kernel
  reg [3 : 0] kernel;
  wire [3 : 0] kernel$D_IN;
  wire kernel$EN;

  // register p0_rv
  reg [1 : 0] p0_rv;
  wire [1 : 0] p0_rv$D_IN;
  wire p0_rv$EN;

  // register p1_rv
  reg [1 : 0] p1_rv;
  wire [1 : 0] p1_rv$D_IN;
  wire p1_rv$EN;

  // register p2_rv
  reg [1 : 0] p2_rv;
  wire [1 : 0] p2_rv$D_IN;
  wire p2_rv$EN;

  // register p3_rv
  reg [1 : 0] p3_rv;
  wire [1 : 0] p3_rv$D_IN;
  wire p3_rv$EN;

  // register shift_amount
  reg [9 : 0] shift_amount;
  wire [9 : 0] shift_amount$D_IN;
  wire shift_amount$EN;

  // ports of submodule inQ
  wire [255 : 0] inQ$D_IN, inQ$D_OUT;
  wire inQ$CLR, inQ$DEQ, inQ$EMPTY_N, inQ$ENQ, inQ$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL__Q1;

  // inputs to muxes for submodule ports
  wire [255 : 0] MUX__unnamed__1$write_1__VAL_1,
		 MUX__unnamed__1$write_1__VAL_2;

  // remaining internal signals
  wire [9 : 0] x__h3241;

  // action method put
  assign RDY_put = inQ$FULL_N ;

  // action method configure
  assign RDY_configure = 1'd1 ;

  // actionvalue method get
  assign get = _unnamed__1 ;
  assign RDY_get = p1_rv[1] ;

  // submodule inQ
  FIFO2 #(.width(32'd256), .guarded(1'd1)) inQ(.RST(RST_N),
					       .CLK(CLK),
					       .D_IN(inQ$D_IN),
					       .ENQ(inQ$ENQ),
					       .DEQ(inQ$DEQ),
					       .CLR(inQ$CLR),
					       .D_OUT(inQ$D_OUT),
					       .FULL_N(inQ$FULL_N),
					       .EMPTY_N(inQ$EMPTY_N));

  // rule RL__Q1
  assign WILL_FIRE_RL__Q1 =
	     p0_rv[1] && !p2_rv$port1__read[1] && !p1_rv$port1__read[1] &&
	     !p2_rv[1] ;

  // inputs to muxes for submodule ports
  assign MUX__unnamed__1$write_1__VAL_1 = _unnamed_ | _unnamed__1 ;
  assign MUX__unnamed__1$write_1__VAL_2 = _unnamed__1 << x__h3241 ;

  // inlined wires
  assign p0_rv$port1__read = WILL_FIRE_RL__Q1 ? 2'd0 : p0_rv ;
  assign p0_rv$EN_port1__write = inQ$EMPTY_N && !p0_rv$port1__read[1] ;
  assign p0_rv$port2__read =
	     p0_rv$EN_port1__write ? 2'd3 : p0_rv$port1__read ;
  assign p1_rv$port1__read = EN_get ? 2'd0 : p1_rv ;
  assign p1_rv$EN_port1__write = WILL_FIRE_RL__Q1 && count == kernel - 4'd1 ;
  assign p1_rv$port2__read =
	     p1_rv$EN_port1__write ? 2'd3 : p1_rv$port1__read ;
  assign p2_rv$port1__read = p2_rv[1] ? 2'd0 : p2_rv ;
  assign p2_rv$port2__read = WILL_FIRE_RL__Q1 ? 2'd3 : p2_rv$port1__read ;

  // register _unnamed_
  assign _unnamed_$D_IN = inQ$D_OUT ;
  assign _unnamed_$EN = inQ$EMPTY_N && !p0_rv$port1__read[1] ;

  // register _unnamed__1
  assign _unnamed__1$D_IN =
	     WILL_FIRE_RL__Q1 ?
	       MUX__unnamed__1$write_1__VAL_1 :
	       MUX__unnamed__1$write_1__VAL_2 ;
  assign _unnamed__1$EN = WILL_FIRE_RL__Q1 || p2_rv[1] ;

  // register _unnamed__2
  assign _unnamed__2$D_IN = 256'h0 ;
  assign _unnamed__2$EN = 1'b0 ;

  // register _unnamed__3
  assign _unnamed__3$D_IN = 256'h0 ;
  assign _unnamed__3$EN = 1'b0 ;

  // register count
  assign count$D_IN = count + 4'd1 ;
  assign count$EN = WILL_FIRE_RL__Q1 ;

  // register kernel
  assign kernel$D_IN = configure_ker ;
  assign kernel$EN = EN_configure ;

  // register p0_rv
  assign p0_rv$D_IN = p0_rv$port2__read ;
  assign p0_rv$EN = 1'b1 ;

  // register p1_rv
  assign p1_rv$D_IN = p1_rv$port2__read ;
  assign p1_rv$EN = 1'b1 ;

  // register p2_rv
  assign p2_rv$D_IN = p2_rv$port2__read ;
  assign p2_rv$EN = 1'b1 ;

  // register p3_rv
  assign p3_rv$D_IN = p3_rv ;
  assign p3_rv$EN = 1'b1 ;

  // register shift_amount
  assign shift_amount$D_IN = configure_shift ;
  assign shift_amount$EN = EN_configure ;

  // submodule inQ
  assign inQ$D_IN = put_datas ;
  assign inQ$ENQ = EN_put ;
  assign inQ$DEQ = inQ$EMPTY_N && !p0_rv$port1__read[1] ;
  assign inQ$CLR = 1'b0 ;

  // remaining internal signals
  assign x__h3241 = { shift_amount[6:0], 3'd0 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        _unnamed_ <= `BSV_ASSIGNMENT_DELAY 256'd0;
	_unnamed__1 <= `BSV_ASSIGNMENT_DELAY 256'd0;
	_unnamed__2 <= `BSV_ASSIGNMENT_DELAY 256'd0;
	_unnamed__3 <= `BSV_ASSIGNMENT_DELAY 256'd0;
	count <= `BSV_ASSIGNMENT_DELAY 4'd0;
	kernel <= `BSV_ASSIGNMENT_DELAY 4'd0;
	p0_rv <= `BSV_ASSIGNMENT_DELAY 2'd0;
	p1_rv <= `BSV_ASSIGNMENT_DELAY 2'd0;
	p2_rv <= `BSV_ASSIGNMENT_DELAY 2'd0;
	p3_rv <= `BSV_ASSIGNMENT_DELAY 2'd0;
	shift_amount <= `BSV_ASSIGNMENT_DELAY 10'd0;
      end
    else
      begin
        if (_unnamed_$EN) _unnamed_ <= `BSV_ASSIGNMENT_DELAY _unnamed_$D_IN;
	if (_unnamed__1$EN)
	  _unnamed__1 <= `BSV_ASSIGNMENT_DELAY _unnamed__1$D_IN;
	if (_unnamed__2$EN)
	  _unnamed__2 <= `BSV_ASSIGNMENT_DELAY _unnamed__2$D_IN;
	if (_unnamed__3$EN)
	  _unnamed__3 <= `BSV_ASSIGNMENT_DELAY _unnamed__3$D_IN;
	if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (kernel$EN) kernel <= `BSV_ASSIGNMENT_DELAY kernel$D_IN;
	if (p0_rv$EN) p0_rv <= `BSV_ASSIGNMENT_DELAY p0_rv$D_IN;
	if (p1_rv$EN) p1_rv <= `BSV_ASSIGNMENT_DELAY p1_rv$D_IN;
	if (p2_rv$EN) p2_rv <= `BSV_ASSIGNMENT_DELAY p2_rv$D_IN;
	if (p3_rv$EN) p3_rv <= `BSV_ASSIGNMENT_DELAY p3_rv$D_IN;
	if (shift_amount$EN)
	  shift_amount <= `BSV_ASSIGNMENT_DELAY shift_amount$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    _unnamed_ =
	256'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    _unnamed__1 =
	256'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    _unnamed__2 =
	256'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    _unnamed__3 =
	256'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    count = 4'hA;
    kernel = 4'hA;
    p0_rv = 2'h2;
    p1_rv = 2'h2;
    p2_rv = 2'h2;
    p3_rv = 2'h2;
    shift_amount = 10'h2AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[7:0]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[15:8]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[23:16]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[31:24]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[39:32]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[47:40]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[55:48]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[63:56]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[71:64]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1) $write(" %d ", $unsigned(_unnamed_[79:72]));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL__Q1)
	$display(" ---------------- %d -------------- ", $unsigned(count));
  end
  // synopsys translate_on
endmodule  // mkCoalesce2

