//
// Generated by Bluespec Compiler, version untagged-gad02e931 (build ad02e931)
//
// On Tue Jan 11 12:13:00 GMT 2022
//
//
// Ports:
// Name                         I/O  size props
// RDY_put                        O     1 const
// result                         O     8 reg
// RDY_result                     O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_datas                      I    72
// put_sumPrev                    I     8
// EN_put                         I     1
// EN_result                      I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkConv(CLK,
	      RST_N,

	      put_datas,
	      put_sumPrev,
	      EN_put,
	      RDY_put,

	      EN_result,
	      result,
	      RDY_result);
  input  CLK;
  input  RST_N;

  // action method put
  input  [71 : 0] put_datas;
  input  [7 : 0] put_sumPrev;
  input  EN_put;
  output RDY_put;

  // actionvalue method result
  input  EN_result;
  output [7 : 0] result;
  output RDY_result;

  // signals for module outputs
  wire [7 : 0] result;
  wire RDY_put, RDY_result;

  // register sIn
  reg [71 : 0] sIn;
  wire [71 : 0] sIn$D_IN;
  wire sIn$EN;

  // ports of submodule s2
  wire [23 : 0] s2$put_datas;
  wire [7 : 0] s2$result;
  wire s2$EN_put, s2$EN_result, s2$RDY_result;

  // ports of submodule s_0
  wire [23 : 0] s_0$put_datas;
  wire [7 : 0] s_0$result;
  wire s_0$EN_put, s_0$EN_result, s_0$RDY_result;

  // ports of submodule s_1
  wire [23 : 0] s_1$put_datas;
  wire [7 : 0] s_1$result;
  wire s_1$EN_put, s_1$EN_result, s_1$RDY_result;

  // ports of submodule s_2
  wire [23 : 0] s_2$put_datas;
  wire [7 : 0] s_2$result;
  wire s_2$EN_put, s_2$EN_result, s_2$RDY_result;

  // action method put
  assign RDY_put = 1'd1 ;

  // actionvalue method result
  assign result = s2$result ;
  assign RDY_result = s2$RDY_result ;

  // submodule s2
  mkSumTree s2(.CLK(CLK),
	       .RST_N(RST_N),
	       .put_datas(s2$put_datas),
	       .EN_put(s2$EN_put),
	       .EN_result(s2$EN_result),
	       .RDY_put(),
	       .result(s2$result),
	       .RDY_result(s2$RDY_result));

  // submodule s_0
  mkSumTree s_0(.CLK(CLK),
		.RST_N(RST_N),
		.put_datas(s_0$put_datas),
		.EN_put(s_0$EN_put),
		.EN_result(s_0$EN_result),
		.RDY_put(),
		.result(s_0$result),
		.RDY_result(s_0$RDY_result));

  // submodule s_1
  mkSumTree s_1(.CLK(CLK),
		.RST_N(RST_N),
		.put_datas(s_1$put_datas),
		.EN_put(s_1$EN_put),
		.EN_result(s_1$EN_result),
		.RDY_put(),
		.result(s_1$result),
		.RDY_result(s_1$RDY_result));

  // submodule s_2
  mkSumTree s_2(.CLK(CLK),
		.RST_N(RST_N),
		.put_datas(s_2$put_datas),
		.EN_put(s_2$EN_put),
		.EN_result(s_2$EN_result),
		.RDY_put(),
		.result(s_2$result),
		.RDY_result(s_2$RDY_result));

  // register sIn
  assign sIn$D_IN =
	     { put_datas[71:64] + put_sumPrev,
	       put_datas[63:56] + put_sumPrev,
	       put_datas[55:48] + put_sumPrev,
	       put_datas[47:40] + put_sumPrev,
	       put_datas[39:32] + put_sumPrev,
	       put_datas[31:24] + put_sumPrev,
	       put_datas[23:16] + put_sumPrev,
	       put_datas[15:8] + put_sumPrev,
	       put_datas[7:0] + put_sumPrev } ;
  assign sIn$EN = EN_put ;

  // submodule s2
  assign s2$put_datas = { s_2$result, s_1$result, s_0$result } ;
  assign s2$EN_put = s_0$RDY_result && s_1$RDY_result && s_2$RDY_result ;
  assign s2$EN_result = EN_result ;

  // submodule s_0
  assign s_0$put_datas = sIn[39:16] ;
  assign s_0$EN_put = 1'd1 ;
  assign s_0$EN_result = s_0$RDY_result && s_1$RDY_result && s_2$RDY_result ;

  // submodule s_1
  assign s_1$put_datas = sIn[55:32] ;
  assign s_1$EN_put = 1'd1 ;
  assign s_1$EN_result = s_0$RDY_result && s_1$RDY_result && s_2$RDY_result ;

  // submodule s_2
  assign s_2$put_datas = sIn[71:48] ;
  assign s_2$EN_put = 1'd1 ;
  assign s_2$EN_result = s_0$RDY_result && s_1$RDY_result && s_2$RDY_result ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (sIn$EN) sIn <= `BSV_ASSIGNMENT_DELAY sIn$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    sIn = 72'hAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkConv

