//
// Generated by Bluespec Compiler, version untagged-gad02e931 (build ad02e931)
//
// On Tue Jan 11 12:13:00 GMT 2022
//
//
// Ports:
// Name                         I/O  size props
// RDY_put                        O     1 const
// result                         O     8 reg
// RDY_result                     O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_datas                      I    24 reg
// EN_put                         I     1
// EN_result                      I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkSumTree(CLK,
		 RST_N,

		 put_datas,
		 EN_put,
		 RDY_put,

		 EN_result,
		 result,
		 RDY_result);
  input  CLK;
  input  RST_N;

  // action method put
  input  [23 : 0] put_datas;
  input  EN_put;
  output RDY_put;

  // actionvalue method result
  input  EN_result;
  output [7 : 0] result;
  output RDY_result;

  // signals for module outputs
  wire [7 : 0] result;
  wire RDY_put, RDY_result;

  // register s0_0
  reg [7 : 0] s0_0;
  wire [7 : 0] s0_0$D_IN;
  wire s0_0$EN;

  // register s0_1
  reg [7 : 0] s0_1;
  wire [7 : 0] s0_1$D_IN;
  wire s0_1$EN;

  // register s0_2
  reg [7 : 0] s0_2;
  wire [7 : 0] s0_2$D_IN;
  wire s0_2$EN;

  // register s1
  reg [7 : 0] s1;
  wire [7 : 0] s1$D_IN;
  wire s1$EN;

  // ports of submodule sum
  wire [7 : 0] sum$D_IN, sum$D_OUT;
  wire sum$CLR, sum$DEQ, sum$EMPTY_N, sum$ENQ, sum$FULL_N;

  // action method put
  assign RDY_put = 1'd1 ;

  // actionvalue method result
  assign result = sum$D_OUT ;
  assign RDY_result = sum$EMPTY_N ;

  // submodule sum
  FIFO2 #(.width(32'd8), .guarded(1'd1)) sum(.RST(RST_N),
					     .CLK(CLK),
					     .D_IN(sum$D_IN),
					     .ENQ(sum$ENQ),
					     .DEQ(sum$DEQ),
					     .CLR(sum$CLR),
					     .D_OUT(sum$D_OUT),
					     .FULL_N(sum$FULL_N),
					     .EMPTY_N(sum$EMPTY_N));

  // register s0_0
  assign s0_0$D_IN = put_datas[7:0] ;
  assign s0_0$EN = EN_put ;

  // register s0_1
  assign s0_1$D_IN = put_datas[15:8] ;
  assign s0_1$EN = EN_put ;

  // register s0_2
  assign s0_2$D_IN = put_datas[23:16] ;
  assign s0_2$EN = EN_put ;

  // register s1
  assign s1$D_IN = s0_0 + s0_1 + s0_2 ;
  assign s1$EN = 1'd1 ;

  // submodule sum
  assign sum$D_IN = s1 ;
  assign sum$ENQ = sum$FULL_N ;
  assign sum$DEQ = EN_result ;
  assign sum$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        s0_0 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_2 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (s0_0$EN) s0_0 <= `BSV_ASSIGNMENT_DELAY s0_0$D_IN;
	if (s0_1$EN) s0_1 <= `BSV_ASSIGNMENT_DELAY s0_1$D_IN;
	if (s0_2$EN) s0_2 <= `BSV_ASSIGNMENT_DELAY s0_2$D_IN;
	if (s1$EN) s1 <= `BSV_ASSIGNMENT_DELAY s1$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    s0_0 = 8'hAA;
    s0_1 = 8'hAA;
    s0_2 = 8'hAA;
    s1 = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkSumTree

