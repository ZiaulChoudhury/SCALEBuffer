//
// Generated by Bluespec Compiler, version untagged-gad02e931 (build ad02e931)
//
// On Sun Jan 16 12:42:40 GMT 2022
//
//
// Ports:
// Name                         I/O  size props
// RDY_put                        O     1 const
// result                         O     8 reg
// RDY_result                     O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// put_datas                      I    40 reg
// EN_put                         I     1
// EN_result                      I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkSumTree(CLK,
		 RST_N,

		 put_datas,
		 EN_put,
		 RDY_put,

		 EN_result,
		 result,
		 RDY_result);
  input  CLK;
  input  RST_N;

  // action method put
  input  [39 : 0] put_datas;
  input  EN_put;
  output RDY_put;

  // actionvalue method result
  input  EN_result;
  output [7 : 0] result;
  output RDY_result;

  // signals for module outputs
  wire [7 : 0] result;
  wire RDY_put, RDY_result;

  // register alpha
  reg [3 : 0] alpha;
  wire [3 : 0] alpha$D_IN;
  wire alpha$EN;

  // register s0_0
  reg [7 : 0] s0_0;
  wire [7 : 0] s0_0$D_IN;
  wire s0_0$EN;

  // register s0_1
  reg [7 : 0] s0_1;
  wire [7 : 0] s0_1$D_IN;
  wire s0_1$EN;

  // register s0_2
  reg [7 : 0] s0_2;
  wire [7 : 0] s0_2$D_IN;
  wire s0_2$EN;

  // register s0_3
  reg [7 : 0] s0_3;
  wire [7 : 0] s0_3$D_IN;
  wire s0_3$EN;

  // register s0_4
  reg [7 : 0] s0_4;
  wire [7 : 0] s0_4$D_IN;
  wire s0_4$EN;

  // register s0_5
  reg [7 : 0] s0_5;
  wire [7 : 0] s0_5$D_IN;
  wire s0_5$EN;

  // register s0_6
  reg [7 : 0] s0_6;
  wire [7 : 0] s0_6$D_IN;
  wire s0_6$EN;

  // register s0_7
  reg [7 : 0] s0_7;
  wire [7 : 0] s0_7$D_IN;
  wire s0_7$EN;

  // register s1_0
  reg [7 : 0] s1_0;
  wire [7 : 0] s1_0$D_IN;
  wire s1_0$EN;

  // register s1_1
  reg [7 : 0] s1_1;
  wire [7 : 0] s1_1$D_IN;
  wire s1_1$EN;

  // register s1_2
  reg [7 : 0] s1_2;
  wire [7 : 0] s1_2$D_IN;
  wire s1_2$EN;

  // register s1_3
  reg [7 : 0] s1_3;
  wire [7 : 0] s1_3$D_IN;
  wire s1_3$EN;

  // register s2_0
  reg [7 : 0] s2_0;
  wire [7 : 0] s2_0$D_IN;
  wire s2_0$EN;

  // register s2_1
  reg [7 : 0] s2_1;
  wire [7 : 0] s2_1$D_IN;
  wire s2_1$EN;

  // ports of submodule sum
  wire [7 : 0] sum$D_IN, sum$D_OUT;
  wire sum$CLR, sum$DEQ, sum$EMPTY_N, sum$ENQ, sum$FULL_N;

  // action method put
  assign RDY_put = 1'd1 ;

  // actionvalue method result
  assign result = sum$D_OUT ;
  assign RDY_result = sum$EMPTY_N ;

  // submodule sum
  FIFO2 #(.width(32'd8), .guarded(1'd1)) sum(.RST(RST_N),
					     .CLK(CLK),
					     .D_IN(sum$D_IN),
					     .ENQ(sum$ENQ),
					     .DEQ(sum$DEQ),
					     .CLR(sum$CLR),
					     .D_OUT(sum$D_OUT),
					     .FULL_N(sum$FULL_N),
					     .EMPTY_N(sum$EMPTY_N));

  // register alpha
  assign alpha$D_IN = 4'h0 ;
  assign alpha$EN = 1'b0 ;

  // register s0_0
  assign s0_0$D_IN = put_datas[7:0] ;
  assign s0_0$EN = EN_put ;

  // register s0_1
  assign s0_1$D_IN = put_datas[15:8] ;
  assign s0_1$EN = EN_put ;

  // register s0_2
  assign s0_2$D_IN = put_datas[23:16] ;
  assign s0_2$EN = EN_put ;

  // register s0_3
  assign s0_3$D_IN = put_datas[31:24] ;
  assign s0_3$EN = EN_put ;

  // register s0_4
  assign s0_4$D_IN = put_datas[39:32] ;
  assign s0_4$EN = EN_put ;

  // register s0_5
  assign s0_5$D_IN = 8'h0 ;
  assign s0_5$EN = 1'b0 ;

  // register s0_6
  assign s0_6$D_IN = 8'h0 ;
  assign s0_6$EN = 1'b0 ;

  // register s0_7
  assign s0_7$D_IN = 8'h0 ;
  assign s0_7$EN = 1'b0 ;

  // register s1_0
  assign s1_0$D_IN = s0_0 + s0_1 ;
  assign s1_0$EN = 1'd1 ;

  // register s1_1
  assign s1_1$D_IN = s0_1 + s0_3 ;
  assign s1_1$EN = 1'd1 ;

  // register s1_2
  assign s1_2$D_IN = s0_2 + s0_5 ;
  assign s1_2$EN = 1'd1 ;

  // register s1_3
  assign s1_3$D_IN = s0_3 + s0_7 ;
  assign s1_3$EN = 1'd1 ;

  // register s2_0
  assign s2_0$D_IN = s1_0 + s1_1 ;
  assign s2_0$EN = 1'd1 ;

  // register s2_1
  assign s2_1$D_IN = s1_1 + s1_3 ;
  assign s2_1$EN = 1'd1 ;

  // submodule sum
  assign sum$D_IN = s2_0 + s2_1 ;
  assign sum$ENQ = sum$FULL_N ;
  assign sum$DEQ = EN_result ;
  assign sum$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        alpha <= `BSV_ASSIGNMENT_DELAY 4'd5;
	s0_0 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_2 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_3 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_4 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_5 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_6 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s0_7 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s1_0 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s1_1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s1_2 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s1_3 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s2_0 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	s2_1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (alpha$EN) alpha <= `BSV_ASSIGNMENT_DELAY alpha$D_IN;
	if (s0_0$EN) s0_0 <= `BSV_ASSIGNMENT_DELAY s0_0$D_IN;
	if (s0_1$EN) s0_1 <= `BSV_ASSIGNMENT_DELAY s0_1$D_IN;
	if (s0_2$EN) s0_2 <= `BSV_ASSIGNMENT_DELAY s0_2$D_IN;
	if (s0_3$EN) s0_3 <= `BSV_ASSIGNMENT_DELAY s0_3$D_IN;
	if (s0_4$EN) s0_4 <= `BSV_ASSIGNMENT_DELAY s0_4$D_IN;
	if (s0_5$EN) s0_5 <= `BSV_ASSIGNMENT_DELAY s0_5$D_IN;
	if (s0_6$EN) s0_6 <= `BSV_ASSIGNMENT_DELAY s0_6$D_IN;
	if (s0_7$EN) s0_7 <= `BSV_ASSIGNMENT_DELAY s0_7$D_IN;
	if (s1_0$EN) s1_0 <= `BSV_ASSIGNMENT_DELAY s1_0$D_IN;
	if (s1_1$EN) s1_1 <= `BSV_ASSIGNMENT_DELAY s1_1$D_IN;
	if (s1_2$EN) s1_2 <= `BSV_ASSIGNMENT_DELAY s1_2$D_IN;
	if (s1_3$EN) s1_3 <= `BSV_ASSIGNMENT_DELAY s1_3$D_IN;
	if (s2_0$EN) s2_0 <= `BSV_ASSIGNMENT_DELAY s2_0$D_IN;
	if (s2_1$EN) s2_1 <= `BSV_ASSIGNMENT_DELAY s2_1$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    alpha = 4'hA;
    s0_0 = 8'hAA;
    s0_1 = 8'hAA;
    s0_2 = 8'hAA;
    s0_3 = 8'hAA;
    s0_4 = 8'hAA;
    s0_5 = 8'hAA;
    s0_6 = 8'hAA;
    s0_7 = 8'hAA;
    s1_0 = 8'hAA;
    s1_1 = 8'hAA;
    s1_2 = 8'hAA;
    s1_3 = 8'hAA;
    s2_0 = 8'hAA;
    s2_1 = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkSumTree

